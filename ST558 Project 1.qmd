---
title: "ST558"
format: html
editor: visual
editor_options: 
  chunk_output_type: console
---

## Public Use Microdata Sample (PUMS) Query

Preparing R packages to simplify the query process

```{r}
#install.packages("httr")
#install.packages("jsonlite")
#install.packages("tidycensus")


# Accessed via get_acs() function
library(tidycensus)
library(httr)
library(jsonlite)
library(dplyr)
library(tibble)
library(ggplot2)
library(tidyr)
library(hms)
library(lubridate)

```

Creating helper function to assist with query process for APIs. This function will convert the raw content to character strings, parse the JSON data, and then convert the data into a tibble.

```{r}
# Helper function to process API response
process_api_response <- function(api_response) {
  # Check if the response was successful
  if (api_response$status_code != 200) {
    stop("Error: API request failed with status code ", api_response$status_code)
  }
  
  # Convert raw content to character string
  content_string <- rawToChar(api_response$content)
  
  # Parse JSON data
  parsed_data <- fromJSON(content_string)
  
  # First row contains column names, the rest is the data
  column_names <- parsed_data[1, ]
  data_rows <- parsed_data[-1, ]
  
  # Convert to tibble and set column names
  tibble_data <- as_tibble(data_rows)
  colnames(tibble_data) <- column_names
  
  # creating new variable in order to check if variables are numeric
  valid_numeric_vars <- c("AGEP", "GASP", "GRPIP", "JWAP", "JWDP", "JWMNP", "PWGTP")
   
  # Created loop to convert proper numeric variables to numeric
  for(var in colnames(tibble_data)){
    if(var %in% valid_numeric_vars){
      tibble_data[[var]] <- as.numeric(tibble_data[[var]])
    }
  }
  
  # New variable to check for categorical variables
  valid_categorical_vars <- c("FER", "HHL", "HISPEED", "JWTRNS", "SCH", "SCHL", "SEX")
  
  # Created loop to convert proper categorical variables to factor
   for(var in colnames(tibble_data)){
    if(var %in% valid_categorical_vars){
      tibble_data[[var]] <- as.factor(tibble_data[[var]])
    }
  }
  
  #Pasting correct time values in for JWAP
  if("JWAP" %in% colnames(tibble_data)) {
  tibble_data <- tibble_data |>
   left_join(JWAP_intervals, join_by(JWAP)) |>
    rename(work_arrival_time = middle_time,
           arrival_meridiem = meridiem) |>
    select(-JWAP)
  } 
  
  #Pasting correct time values in for JWDP
   if("JWDP" %in% colnames(tibble_data)) {
  tibble_data <- tibble_data |>
   left_join(JWDP_intervals, join_by(JWDP)) |>
    rename(work_departure_time = middle_time2,
           departure_meridiem = meridiem2) |>
    select(-JWDP)
  } 
  
  return(tibble_data)
}

```

Creating a year validation function in order to confirm the only correct years (2022 to 2010) are queried.

```{r}
# 2. Function to validate the year
validate_year <- function(year) {
  cat("API year is :", year)
  if (year < 2010 || year > 2022) {
    stop("Invalid year. Year must be between 2010 and 2022.")
  }
}
```

Creating a function to validate and process the numeric variables


```{r}
# 3. Function to validate and process numeric variables
process_numeric_vars <- function(numeric_vars = c("AGEP", "PWGTP")) {
  valid_numeric_vars <- c("AGEP", "GASP", "GRPIP", "JWAP", "JWDP", "JWMNP", "PWGTP")
  
  # Check PWGTP is always included
  if (!"PWGTP" %in% numeric_vars) {
    numeric_vars <- c(numeric_vars, "PWGTP")
  }
  
  # Validate numeric variables
  if (!all(numeric_vars %in% valid_numeric_vars)) {
    stop("Invalid numeric variables. Valid options: AGEP, GASP, GRPIP, JWAP, JWDP, JWMNP, PWGTP.")
  }
  
  # Check at least one numeric variable other than PWGTP
  if (!any(numeric_vars %in% valid_numeric_vars[valid_numeric_vars != "PWGTP"])) {
    stop("At least one numeric variable other than PWGTP must be returned.")
  } 
} 
```


The next step is to analyze the JWAP and JWDP variable independently in order to grab the variables 


```{r}
# Function to process time variables
process_time_variable <- function(variable_name) {
 
   # Grabbing information from API
  temp <- httr::GET(paste0("https://api.census.gov/data/2022/acs/acs1/pums/variables/", variable_name, ".json"))
  temp_list <- temp$content |> rawToChar() |> jsonlite::fromJSON()
  
  # Getting just the variable names and their values
  time_values <- temp_list$values$item
  time_vals_sorted <- time_values[sort(names(time_values))]
  
  # Converting the values into a tibble
  time_tibble <- tibble(id = seq(0, length(time_vals_sorted) - 1), value = time_vals_sorted)
  
  # Converting to wide format
  time_wide <- separate_wider_delim(time_tibble, 
                                     cols = c("value"), 
                                     delim = " ", 
                                     names = c("start", "meridiem", "to", "end", "meridiem_2"), 
                                     too_few = "debug", 
                                     names_repair = "unique", 
                                     too_many = "drop") 
  
  # Select the needed rows and convert to usable format
  time_intervals <- time_wide |>
    select(id, start, meridiem, end, meridiem_2) |>
    mutate(start = parse_hm(start),
           end = parse_hm(end),
           variable_name = id)  
  
  # Make row 1 display NA across all columns for row 1    
  time_intervals[1, ] <- NA
  
  # Creating middle time value variable
  time_intervals <- time_intervals |>
    mutate(interval = (end - start) / 2,
           interval = as.numeric(interval),
           interval = as.period(interval))

  # Turning start into a period   
  time_intervals <- time_intervals |>
    mutate(start = as.period(start),
           middle_time = as.duration(start + interval)) |>
    select(middle_time, variable_name, meridiem) 
  
  # Turning the first row variable back to 0
  time_intervals[1, 2] <- 0
          
  # Converting back to a time variable        
  time_intervals <- time_intervals |>
    mutate(middle_time = hms::hms(seconds = middle_time))
  
  return(time_intervals)
} 

#Renaming variables to insure they work in the helper function
JWAP_intervals <- process_time_variable("JWAP")
JWAP_intervals <- JWAP_intervals |>
  rename(JWAP = variable_name)
         

JWDP_intervals <- process_time_variable("JWDP")
JWDP_intervals <- JWDP_intervals |>
  rename(JWDP = variable_name,
         middle_time2 = middle_time,
         meridiem2 = meridiem)

```
 
 
 
 
```{r}
process_categorical_vars <- function(categorical_vars = c("SEX")) {
  valid_categorical_vars <- c("FER", "HHL", "HISPEED", "JWTRNS", "SCH", "SCHL", "SEX")
  
  # Validate categorical variables
  if (!all(categorical_vars %in% valid_categorical_vars)) {
    stop("Invalid categorical variables. Valid options: FER, HHL, HISPEED, JWAP, JWDP, JWTRNS, SCH, SCHL, SEX.")
  }
  return(categorical_vars)
}
```

##Check that the value specified by the user is one of the above values

Main function to Query the API

```{r}
# 5. Main function: Query the API
query_census_pums <- function(
    year = 2022,
    numeric_vars = c("AGEP", "PWGTP"),
    categorical_vars = c("SEX"),
    geography_level = "All",
    geography_subset = NULL
) {
  # Validate the year
  validate_year(year)
  
  # Validate numeric variables
  process_numeric_vars(numeric_vars)
  
  # Validate categorical variables
  process_categorical_vars(categorical_vars)
  
  # Get API URL 
  base_url <- "https://api.census.gov/data"
  pathparam <- "acs/acs1/pums"  
  
  # Get the full URL
  url <- paste0(base_url, "/", year, "/", pathparam, "?get=", 
                paste(c(numeric_vars, categorical_vars), collapse = ",")) #was there a reason to have school = 24 here?
  
  # Check geography subset and add it to API call
  if (!is.null(geography_subset)) {
    url <- paste0(url, "&for=", geography_level, ":", geography_subset)
  }
  print(url)
  
  # API call using httr::GET
  api_response <- GET(url)
  
  # Check if the request was successful
  if (http_error(api_response)) {
    stop("API request failed: ", status_code(api_response))
  }
  
  # Process the response into a tibble
  data <- process_api_response(api_response)
  
  # Return the data 
  return(data)
}
print(url)
```

Testing Query with single year

```{r}
# Example for the single year 2022 with numeric and categorical variables
result <- query_census_pums(
  year = 2022, 
  numeric_vars = c("AGEP", "PWGTP", "GASP", "JWDP", "JWAP"),
  categorical_vars = c("SEX", "HISPEED"),
  geography_level = "state",
  geography_subset = "10"
)

# View the results
print ("end of function")
print(result)


```

Function for multiple years

```{r}
# 6. Function for multiple years
query_multiple_years <- function(
    years,                       
    numeric_vars = c("AGEP", "PWGTP"),  
    categorical_vars = c("SEX"),        
    geography_level = "All",            
    geography_subset = NULL             
) {
  all_years_data <- list()
  
  # Loop through each year
  for (year in years) {
    # Check if the year is valid
    #validate_year(year)
    cat("\nyear:", year)
    # Validate the year.    
    if (year < 2010 || year > 2022) {
      print(paste("Skipping invalid year:", year))
      next  # Skip this iteration and continue with the next year
    }
    
    # Get data for the current year using the single year function
    yearly_data <- query_census_pums(
      year = year,
      numeric_vars = numeric_vars,
      categorical_vars = categorical_vars,
      geography_level = geography_level,
      geography_subset = geography_subset
    )
    
    # Add a year column 
    yearly_data$year <- year
    
    # Store the current year data in the list
    all_years_data[[as.character(year)]] <- yearly_data
  }
  
  # Combine all the  data into one dataset
  final_data <- bind_rows(all_years_data)
  
  # Return dataset
  return(final_data)
}
```

Testing the year 2022 to ensure query is working correctly



TEST
```{r}

# Example for the single year 2022 with numeric and categorical variables
result <- query_census_pums(
  year = 2022, 
  numeric_vars = c("JWAP", "GASP"),
  categorical_vars = c("SEX", "HISPEED"),
  geography_level = "state",
  geography_subset = "10"
)

# View the results
print ("end of function")
print(result)
```



```{r}
# Example of multiple years of data
multi_year_result <- query_multiple_years(
  years = c( 2016, 2017, 2018, 2024),    
  numeric_vars = c("AGEP", "PWGTP"),  
  categorical_vars = c("SEX", "HISPEED"),  
  geography_level = "state",  
  geography_subset = "10"     
)



# View the result
print(multi_year_result)
```



Tibble processing

```{r}
#Run these in your console
# After processing your tibble
class(multi_year_result) <- c("census", class(multi_year_result))


# Define custom summary function for the 'census' class
summary.census <- function(census_data, 
                           numeric_vars = NULL, 
                           categorical_vars = NULL) {
  
  # Ensure PWGTP exists and is numeric
  if (!"PWGTP" %in% names(census_data)) {
    stop("Weight variable 'PWGTP' is missing from the dataset.")
  }
  
  # Separate numeric and categorical columns from the data
  if (is.null(numeric_vars)) {
    numeric_vars <- names(census_data)[sapply(census_data, is.numeric) & names(census_data) != "PWGTP"]
  }
  
  if (is.null(categorical_vars)) {
    categorical_vars <- names(census_data)[sapply(census_data, is.factor)]
  }
```

Weighted Mean and standard deviation summaries

```{r}
# Weighted mean and standard deviation calculations
  summarize_numeric <- function(var_name, data) {
    numeric_vector <- as.numeric(data[[var_name]])
    weight_vector <- as.numeric(data[["PWGTP"]])
    
    # Check for missing values in the weight vector
    if (any(is.na(weight_vector))) {
      stop("Missing values found in the weight variable 'PWGTP'.")
    }
    
    # Calculate weighted mean
    weighted_mean <- sum(numeric_vector * weight_vector, na.rm = TRUE) / sum(weight_vector, na.rm = TRUE)
    
    # Calculate weighted standard deviation
    weighted_var <- sum(numeric_vector^2 * weight_vector, na.rm = TRUE) / sum(weight_vector, na.rm = TRUE)
    weighted_sd <- sqrt(weighted_var - weighted_mean^2)
    
    return(list(mean = weighted_mean, sd = weighted_sd))
  }
  
  # Initialize a list to store the summary results
  summary_list <- list()
  
  # Summarize numeric variables
  for (var in numeric_vars) {
    summary_list[[var]] <- summarize_numeric(var, census_data)
  }
  
  # Summarize categorical variables (counts)
  for (var in categorical_vars) {
    summary_list[[var]] <- table(census_data[[var]], useNA = "ifany")
  }
  
  return(summary_list)
}

# Example: Use the summary function on your 'result' tibble
summary_result <- summary.census(result, numeric_vars = c("AGEP"), categorical_vars = c("SEX"))
print(summary_result)
```

TODO

```{r}
plot.census <- function(tibble_data, cat_var, num_var) {
  # Create the weighted boxplot
  p <- ggplot(tibble_data, aes(x = get(cat_var), y = get(num_var), weight = PWGTP)) +
    geom_boxplot()# +
   # labs(x = cat_var, y = num_var) +
    #theme_minimal()
  
  print(p)
}



# Plot example
plot.census(census_data, cat_var = "SEX", num_var = "AGEP")
```
